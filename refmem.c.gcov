        -:    0:Source:src/refmem.c
        -:    0:Graph:build/refmem.gcno
        -:    0:Data:build/refmem.gcda
        -:    0:Runs:1
        -:    1:#include "refmem.h"
        -:    2:#include "../demo/hash_table.h"
        -:    3:#include "../demo/common.h"
        -:    4:#include <stdlib.h>
        -:    5:#include <stdio.h>
        -:    6:#include <string.h>
        -:    7:#include <stdbool.h>
        -:    8:#include <assert.h>
        -:    9:
        -:   10:ioopm_list_t *list_delayed_frees;
        -:   11:bool instantiate = true;
        -:   12:bool check = true;
        -:   13:ioopm_list_t *object_list;
        -:   14:static size_t cascade_limit = 100;
        -:   15:
        -:   16:int deallocate_counter = 0; // PRELIMINARY
        -:   17:
        -:   18:// void free_elem(elem_t *element, void *extra)
        -:   19:// {
        -:   20://     free(element->mt);
        -:   21:// }
        -:   22:
        -:   23:// static bool meta_data_compare(elem_t elem1, elem_t elem2)
        -:   24:// {
        -:   25://     return elem1.mt->adress == elem2.mt->adress;
        -:   26:// }
        -:   27:
        7:   28:void remove_from_list(meta_data_t *md)
        -:   29:{
        7:   30:    if (!ioopm_linked_list_is_empty(object_list))
        -:   31:    {
        6:   32:        ioopm_list_iterator_t *iter = ioopm_list_iterator(object_list);
        6:   33:        size_t index = 0;
        -:   34:        do
        -:   35:        {
       15:   36:            if (index != 0)
        -:   37:            {
        9:   38:                ioopm_iterator_next(iter);
        -:   39:            }
       15:   40:            if (ioopm_iterator_current(iter).mt->adress == md->adress)
        -:   41:            {
        6:   42:                ioopm_linked_list_remove(object_list, index);
        6:   43:                ioopm_iterator_destroy(&iter);
        6:   44:                return;
        -:   45:            }
        9:   46:            index++;
        9:   47:        } while (ioopm_iterator_has_next(iter));
        -:   48:
    #####:   49:        ioopm_iterator_destroy(&iter);
        -:   50:    }
        -:   51:}
        -:   52:
       19:   53:meta_data_t *get_meta_data(obj *c)
        -:   54:{
       19:   55:    return c - sizeof(meta_data_t);
        -:   56:}
        -:   57:
       10:   58:obj *allocate(size_t bytes, function1_t destructor)
        -:   59:{
       10:   60:    if (instantiate)
        -:   61:    {
        1:   62:        list_delayed_frees = ioopm_linked_list_create(NULL);
        1:   63:        object_list = ioopm_linked_list_create(NULL);
        1:   64:        instantiate = false;
        -:   65:    }
        -:   66:
       10:   67:    if (deallocate_counter == cascade_limit)
        -:   68:    {
    #####:   69:        deallocate_counter = 0;
        -:   70:    }
        -:   71:
       10:   72:    obj *new_object = (obj *)malloc(sizeof(meta_data_t) + bytes);
        -:   73:
       10:   74:    meta_data_t *meta_data = (meta_data_t *)new_object;
        -:   75:
       10:   76:    meta_data->next = NULL;
       10:   77:    meta_data->adress = &new_object; // + sizeof(meta_data_t);
       10:   78:    meta_data->reference_counter = 0;
       10:   79:    meta_data->destructor = destructor;
        -:   80:
       10:   81:    ioopm_linked_list_append(object_list, mt_elem(meta_data));
        -:   82:
       10:   83:    return new_object + sizeof(meta_data_t);
        -:   84:}
        -:   85:
        1:   86:obj *allocate_array(size_t elements, size_t elem_size, function1_t destructor)
        -:   87:{
        -:   88:
        1:   89:    obj *new_object = (obj *)calloc(elements, elem_size + sizeof(meta_data_t));
        -:   90:
        1:   91:    if (new_object != NULL)
        -:   92:    {
        1:   93:        meta_data_t *meta_data = (meta_data_t *)new_object;
        -:   94:
        1:   95:        meta_data->next = NULL;
        1:   96:        meta_data->adress = &new_object; //+ sizeof(meta_data_t); // check allocate
        1:   97:        meta_data->reference_counter = 0;
        1:   98:        meta_data->destructor = destructor;
        -:   99:    }
        -:  100:
        1:  101:    return new_object + sizeof(meta_data_t);
        -:  102:}
        -:  103:
        3:  104:void retain(obj *c)
        -:  105:{
        3:  106:    meta_data_t *m = get_meta_data(c);
        3:  107:    m->reference_counter++;
        3:  108:}
        -:  109:
        5:  110:void release(obj **c)
        -:  111:{
        5:  112:    if (*c != NULL)
        -:  113:    {
        5:  114:        meta_data_t *meta_data = get_meta_data(*c);
        -:  115:
        5:  116:        meta_data->reference_counter--;
        5:  117:        if (meta_data->reference_counter < 1)
        -:  118:        {
        5:  119:            deallocate(c);
        -:  120:        }
        -:  121:    }
        5:  122:}
        -:  123:
        1:  124:int rc(obj *c)
        -:  125:{
        1:  126:    meta_data_t *meta_data = get_meta_data(c);
        -:  127:    // meta_data->reference_counter++;
        1:  128:    return meta_data->reference_counter;
        -:  129:}
        -:  130:
        7:  131:void deallocate(obj **c)
        -:  132:{
        -:  133:
        7:  134:    meta_data_t *m = get_meta_data(*c);
        -:  135:
        7:  136:    if (m->reference_counter > 0)
        -:  137:    {
    #####:  138:        printf("\nError: Objects with non-zero reference counters can not be deallocated\n");
    #####:  139:        assert(false);
        -:  140:        return;
        -:  141:    }
        -:  142:
        7:  143:    if (deallocate_counter == cascade_limit)
        -:  144:    {
    #####:  145:        ioopm_linked_list_append(list_delayed_frees, ptr_elem(*c));
    #####:  146:        return;
        -:  147:    }
        -:  148:
        7:  149:    deallocate_counter++;
        -:  150:
        7:  151:    remove_from_list(m);
        7:  152:    free(m);
        7:  153:    *c = NULL;
        -:  154:}
        -:  155:
        4:  156:void cleanup_helper(elem_t *element, void *extra)
        -:  157:{
        4:  158:    ioopm_linked_list_remove(object_list, element->i);
        4:  159:}
        -:  160:
        2:  161:void cleanup()
        -:  162:{
        2:  163:    if (!ioopm_linked_list_is_empty(object_list))
        -:  164:    {
        1:  165:        void *not_used = NULL;
        -:  166:        // ioopm_linked_list_apply_to_all(object_list, cleanup_helper, not_used);
        -:  167:
        1:  168:        ioopm_list_t *delete_list = ioopm_linked_list_create(NULL);
        1:  169:        ioopm_list_iterator_t *iter = ioopm_list_iterator(object_list);
        1:  170:        bool first = true;
        1:  171:        int index2 = 0;
        1:  172:        int index = 0;
        -:  173:        do
        -:  174:        {
        4:  175:            if (first)
        -:  176:            {
        1:  177:                first = false;
        -:  178:            }
        -:  179:            else
        -:  180:            {
        3:  181:                ioopm_iterator_next(iter);
        -:  182:            }
        4:  183:            meta_data_t *current = ioopm_iterator_current(iter).mt;
        4:  184:            if (current->reference_counter == 0)
        -:  185:            {
        4:  186:                free(current);
        4:  187:                ioopm_linked_list_append(delete_list, int_elem(index - index2));
        4:  188:                index2++;
        -:  189:            }
        4:  190:            index++;
        4:  191:        } while (ioopm_iterator_has_next(iter));
        1:  192:        ioopm_linked_list_apply_to_all(delete_list, cleanup_helper, not_used);
        1:  193:        ioopm_linked_list_destroy(&delete_list);
        1:  194:        ioopm_iterator_destroy(&iter);
        -:  195:    }
        2:  196:    ioopm_linked_list_clear(list_delayed_frees);
        2:  197:}
        -:  198:
        2:  199:void set_cascade_limit(size_t lim)
        -:  200:{
        2:  201:    cascade_limit = lim;
        2:  202:    deallocate_counter = 0;
        2:  203:}
        -:  204:
        2:  205:ioopm_list_t *get_obj_list()
        -:  206:{
        2:  207:    return object_list;
        -:  208:}
        -:  209:
        2:  210:size_t get_cascade_limit()
        -:  211:{
        2:  212:    return cascade_limit;
        -:  213:}
        -:  214:
        1:  215:void shutdown()
        -:  216:{
        1:  217:    if (object_list != NULL)
        -:  218:    {
        1:  219:        cleanup();
        -:  220:
        -:  221:        // ioopm_linked_list_apply_to_all(object_list, free_elem, NULL);
        1:  222:        ioopm_linked_list_destroy(&object_list);
        -:  223:    }
        1:  224:    if (list_delayed_frees != NULL)
        -:  225:    {
        1:  226:        ioopm_linked_list_destroy(&list_delayed_frees);
        -:  227:    }
        1:  228:}
