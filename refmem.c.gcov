        -:    0:Source:src/refmem.c
        -:    0:Graph:build/refmem.gcno
        -:    0:Data:build/refmem.gcda
        -:    0:Runs:1
        -:    1:#include "refmem.h"
        -:    2:#include "../demo/hash_table.h"
        -:    3:#include "../demo/common.h"
        -:    4:#include <stdlib.h>
        -:    5:#include <stdio.h>
        -:    6:#include <string.h>
        -:    7:#include <stdbool.h>
        -:    8:#include <assert.h>
        -:    9:
        -:   10:ioopm_list_t *list_delayed_frees;
        -:   11:bool instantiate = true;
        -:   12:bool check = true;
        -:   13:ioopm_list_t *object_list;
        -:   14:static size_t cascade_limit = 100;
        -:   15:
        -:   16:int deallocate_counter = 0; // PRELIMINARY
        -:   17:
    #####:   18:void free_elem(elem_t *element, void *extra)
        -:   19:{
    #####:   20:    free(element->mt);
    #####:   21:}
        -:   22:
    #####:   23:static bool meta_data_compare(elem_t elem1, elem_t elem2)
        -:   24:{
    #####:   25:    return elem1.mt->adress == elem2.mt->adress;
        -:   26:}
        -:   27:
        7:   28:void remove_from_list(meta_data_t *md)
        -:   29:{
        7:   30:    if (!ioopm_linked_list_is_empty(object_list))
        -:   31:    {
        6:   32:        ioopm_list_iterator_t *iter = ioopm_list_iterator(object_list);
        6:   33:        size_t index = 0;
        -:   34:        do
        -:   35:        {
        6:   36:            if (index != 0)
        -:   37:            {
    #####:   38:                ioopm_iterator_next(iter);
        -:   39:            }
        6:   40:            if (ioopm_iterator_current(iter).mt->adress == md->adress)
        -:   41:            {
        6:   42:                ioopm_linked_list_remove(object_list, index);
        6:   43:                ioopm_iterator_destroy(&iter);
        6:   44:                return;
        -:   45:            }
    #####:   46:            index++;
    #####:   47:        } while (ioopm_iterator_has_next(iter));
        -:   48:
    #####:   49:        ioopm_iterator_destroy(&iter);
        -:   50:    }
        -:   51:}
        -:   52:
       19:   53:meta_data_t *get_meta_data(obj *c)
        -:   54:{
       19:   55:    return c - sizeof(meta_data_t);
        -:   56:}
        -:   57:
        6:   58:obj *allocate(size_t bytes, function1_t destructor)
        -:   59:{
        6:   60:    if (instantiate)
        -:   61:    {
        1:   62:        list_delayed_frees = ioopm_linked_list_create(NULL);
        1:   63:        object_list = ioopm_linked_list_create(NULL);
        1:   64:        instantiate = false;
        -:   65:    }
        -:   66:
        6:   67:    if (deallocate_counter == cascade_limit)
        -:   68:    {
    #####:   69:        deallocate_counter = 0;
        -:   70:    }
        -:   71:
        6:   72:    obj *new_object = (obj *)malloc(sizeof(meta_data_t) + bytes);
        -:   73:
        6:   74:    meta_data_t *meta_data = (meta_data_t *)new_object;
        -:   75:
        6:   76:    meta_data->next = NULL;
        6:   77:    meta_data->adress = &new_object; // + sizeof(meta_data_t);
        6:   78:    meta_data->reference_counter = 0;
        6:   79:    meta_data->destructor = destructor;
        -:   80:
        6:   81:    ioopm_linked_list_append(object_list, mt_elem(meta_data));
        -:   82:
        6:   83:    return new_object + sizeof(meta_data_t);
        -:   84:}
        -:   85:
        1:   86:obj *allocate_array(size_t elements, size_t elem_size, function1_t destructor)
        -:   87:{
        -:   88:
        1:   89:    obj *new_object = (obj *)calloc(elements, elem_size + sizeof(meta_data_t));
        -:   90:
        1:   91:    if (new_object != NULL)
        -:   92:    {
        1:   93:        meta_data_t *meta_data = (meta_data_t *)new_object;
        -:   94:
        1:   95:        meta_data->next = NULL;
        1:   96:        meta_data->adress = &new_object; //+ sizeof(meta_data_t); // check allocate
        1:   97:        meta_data->reference_counter = 0;
        1:   98:        meta_data->destructor = destructor;
        -:   99:    }
        -:  100:
        1:  101:    return new_object + sizeof(meta_data_t);
        -:  102:}
        -:  103:
        3:  104:void retain(obj *c)
        -:  105:{
        3:  106:    meta_data_t *m = get_meta_data(c);
        3:  107:    m->reference_counter++;
        3:  108:}
        -:  109:
        5:  110:void release(obj **c)
        -:  111:{
        5:  112:    if (*c != NULL)
        -:  113:    {
        5:  114:        meta_data_t *meta_data = get_meta_data(*c);
        -:  115:
        5:  116:        meta_data->reference_counter--;
        5:  117:        if (meta_data->reference_counter < 1)
        -:  118:        {
        5:  119:            deallocate(c);
        -:  120:        }
        -:  121:    }
        5:  122:}
        -:  123:
    #####:  124:int rc(obj *c)
        -:  125:{
    #####:  126:    meta_data_t *meta_data = get_meta_data(c);
        -:  127:    // meta_data->reference_counter++;
    #####:  128:    return meta_data->reference_counter;
        -:  129:}
        -:  130:
        7:  131:void deallocate(obj **c)
        -:  132:{
        -:  133:
        7:  134:    meta_data_t *m = get_meta_data(*c);
        -:  135:
        7:  136:    if (m->reference_counter > 0)
        -:  137:    {
    #####:  138:        printf("\nError: Only non-zero are able to be deallocated\n");
    #####:  139:        assert(false);
        -:  140:        return;
        -:  141:    }
        -:  142:
        7:  143:    if (deallocate_counter == cascade_limit)
        -:  144:    {
    #####:  145:        ioopm_linked_list_append(list_delayed_frees, ptr_elem(*c));
    #####:  146:        return;
        -:  147:    }
        -:  148:
        7:  149:    deallocate_counter++;
        -:  150:
        7:  151:    remove_from_list(m);
        7:  152:    free(m);
        7:  153:    *c = NULL;
        -:  154:}
        -:  155:
    #####:  156:void cleanup_helper(elem_t *element, void *extra)
        -:  157:{
    #####:  158:    ioopm_linked_list_remove(object_list, element->i);
    #####:  159:}
        -:  160:
        1:  161:void cleanup()
        -:  162:{
        1:  163:    if (!ioopm_linked_list_is_empty(object_list))
        -:  164:    {
    #####:  165:        void *not_used = NULL;
        -:  166:        // ioopm_linked_list_apply_to_all(object_list, cleanup_helper, not_used);
        -:  167:
    #####:  168:        ioopm_list_t *delete_list = ioopm_linked_list_create(NULL);
    #####:  169:        ioopm_list_iterator_t *iter = ioopm_list_iterator(object_list);
    #####:  170:        bool first = true;
    #####:  171:        int index2 = 0;
    #####:  172:        int index = 0;
        -:  173:        do
        -:  174:        {
    #####:  175:            if (first)
        -:  176:            {
    #####:  177:                first = false;
        -:  178:            }
        -:  179:            else
        -:  180:            {
    #####:  181:                ioopm_iterator_next(iter);
        -:  182:            }
    #####:  183:            meta_data_t *current = ioopm_iterator_current(iter).mt;
    #####:  184:            if (current->reference_counter == 0)
        -:  185:            {
    #####:  186:                free(current);
    #####:  187:                ioopm_linked_list_append(delete_list, int_elem(index - index2));
    #####:  188:                index2++;
        -:  189:            }
    #####:  190:            index++;
    #####:  191:        } while (ioopm_iterator_has_next(iter));
    #####:  192:        ioopm_linked_list_apply_to_all(delete_list, cleanup_helper, not_used);
    #####:  193:        ioopm_linked_list_destroy(&delete_list);
    #####:  194:        ioopm_iterator_destroy(&iter);
        -:  195:    }
        1:  196:    ioopm_linked_list_clear(list_delayed_frees);
        1:  197:}
        -:  198:
    #####:  199:void set_cascade_limit(size_t lim)
        -:  200:{
    #####:  201:    cascade_limit = lim;
    #####:  202:    deallocate_counter = 0;
    #####:  203:}
        -:  204:
    #####:  205:ioopm_list_t *get_obj_list()
        -:  206:{
    #####:  207:    return object_list;
        -:  208:}
        -:  209:
        1:  210:void shutdown()
        -:  211:{
        1:  212:    if (object_list != NULL)
        -:  213:    {
        1:  214:        cleanup();
        -:  215:
        -:  216:        // ioopm_linked_list_apply_to_all(object_list, free_elem, NULL);
        1:  217:        ioopm_linked_list_destroy(&object_list);
        -:  218:    }
        1:  219:    if (list_delayed_frees != NULL)
        -:  220:    {
        1:  221:        ioopm_linked_list_destroy(&list_delayed_frees);
        -:  222:    }
        1:  223:}
